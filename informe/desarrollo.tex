Para realizar este trabajo, planteamos distintas formas de simular el comportamiento de una red “real”.
 
Realizamos experimentaciones simulando la latencia, variando el delay en que se envían los ACKs y simulando la perdida de paquetes, mediante una probabilidad arbitraria por que la se decide si enviar un paquete o no. Implementamos un cliente custom, para cada una de las experimentaciones que se comunica con un mismo servidor.

Para crear delay en el envío de los ACKs, modificamos el código proporcionado por la cátedra(protocol.py) e implementamos un timer, de modo que cuando se está por enviar un paquete(usando send\_and\_queue), se chequea si es un ACK, y en ese caso, si el valor del delay es mayor a 0, se usa el timer para llamar a la función que envía el paquete pasado el tiempo igual al valor de delay.

De manera similar, para hacer que los paquetes se pierdan con una cierta probabilidad, en el mismo método, donde agregamos el timer, agregamos una condición que chequee si un un valor random es menor a la chance de perder el paquete. En caso de que lo sea, evitamos llamar a la función send del socket, simulando la pérdida del paquete en el otro punto del canal de comunicación.

En las distintas experimentaciones, variamos el delay de 2 maneras, usando valores constantes y un rango de valores aleatorios. Hicimos lo mismo para el delay. 
La elección de valores constantes o aleatorios en cada experimentación, dependió de lo que se estaba testeando. En los casos en los que el objetivo era testear el comportamiento de la red en función de los valores del del delay o de la perdida de paquetes, usamos valores constantes, para tener control sobre la experimentación y poder explicar los resultados. En caso contrario utilizamos valores aleatorios.

Los valores aleatorios, como dijimos, fueron tomados de un rango de valores posibles. Estos rangos variaron en los distintos experimentos. El rango usado para la probabilidad de perder un paquete fue de 0.98 a 1.00 aproximadamente, o sea de hasta un 2\% de chance de perder un paquete. Para el delay usamos rangos de entre 0.05 y 0.15 segundos. Estos valores fueron calculados a partir de observaciones usando ping a distintos dominios de internet(para el delay) y probando valores que fuesen visibles al realizar las experimentaciones.

Una decisión que tomamos para simular mejor el comportamiento de una red “real” fue hacer que los valores aleatorios para el delay y la chance de perder paquetes varíe constantemente en esos rangos, durante la comunicación entre el cliente y el servidor. La implementación de esta funcionalidad fue usar un thread que llama a una función cada 10 milisegundos y toma un valor aleatorio en el rango posible para las variables. De esta forma, el delay y la probabilidad de pérdida de paquetes resultaron realmente aleatorios en las experimentaciones que lo utilizaron.

Como el trabajo consistía en obtener resultados del comportamiento de la red, lo que hicimos fue enviar archivos entre 2 terminales de la red. Para esto usamos el código proporcionado por la cátedra para crear el canal de comunicación, y sobre este canal creamos un protocolo muy simple para enviar archivos de una terminal a otra. En el protocolo, solo el server recibe archivos y el cliente los envía. El protocolo basa la comunicación en una serie de mensajes definidos como constantes de 10 bytes. Utilizamos mensajes de tamaño constante, ya que la función recv de Socket, recibe como parámetro la cantidad de bytes que va a recibir y hasta que no reciba esa cantidad queda bloqueado, entonces nos aseguramos que intercambiando mensajes de tamaño constante, el servidor y el cliente siempre puedan llamar a recv esperando un mensaje de 10 bytes y así continuar con el intercambio de mensajes. De esta manera, el servidor, comienza escuchando en el socket por un mensaje que puede ser una señal para avisar que se va a mandar un nuevo archivo o que se puede cerrar. Si se va a mandar un nuevo archivo, el servidor contesta al cliente un OK, y el cliente al recibirlo manda el tamaño del archivo que va a mandar, luego espera por otro OK del servidor y comienza mandar el archivo. De esta manera, el servidor sabe con que cantidad de bytes llamar a recv para obtener todo el archivo. Al terminar el servidor queda escuchando nuevamente por un mensaje para recibir otro archivo o cerrarse.